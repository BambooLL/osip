<HTML
><HEAD
><TITLE
>oSIP user Manual</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.49"><META
NAME="KEYWORD"
CONTENT="oSIP"><META
NAME="KEYWORD"
CONTENT="SIP"><META
NAME="KEYWORD"
CONTENT="rfc2543"><META
NAME="KEYWORD"
CONTENT="library"><META
NAME="KEYWORD"
CONTENT="telephony"><META
NAME="KEYWORD"
CONTENT="GPL"><META
NAME="KEYWORD"
CONTENT="Linux"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>oSIP user Manual</A
></H1
><H2
CLASS="SUBTITLE"
>A guide to implement SIP agents with the oSIP stack.</H2
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Aymeric Moizard</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>jacK@atosc.org</P
></DIV
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
><B
>Abstract</B
></P
><P
><SPAN
CLASS="QUOTE"
>"The Session Initiation Protocol (SIP) is an application-layer control (signaling) protocol for creating, modifying and terminating sessions with one or more participants. These sessions include Internet multimedia conferences, Internet telephone calls and multimedia distribution. Members in a session can communicate via multicast or via a mesh of unicast relations, or a combination of these."</SPAN
></P
><P
><H3
CLASS="CORPAUTHOR"
>IETF - rfc 2543</H3
></P
></DIV
></DIV
><DIV
CLASS="LEGALNOTICE"
><P
></P
><P
>Copyright (c)  2001  Aymeric MOIZARD.
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1
or any later version published by the Free Software Foundation;
with the Invariant Sections being LIST THEIR TITLES, with the
Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
A copy of the license is included in the section entitled "GNU
Free Documentation License".</P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#SIP-PROTOCOL"
>The SIP protocol</A
></DT
><DD
><DL
><DT
><A
HREF="#SIP-MEDIA"
>SIP is independent of media</A
></DT
><DT
><A
HREF="#AEN42"
>SIP is independent of the transport layer</A
></DT
><DT
><A
HREF="#AEN45"
>SIP is extensible</A
></DT
><DT
><A
HREF="#AEN52"
>SIP and end-user services</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#AEN60"
>SIP overview</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN63"
>SIP syntax</A
></DT
><DT
><A
HREF="#AEN81"
>SIP transactions</A
></DT
><DT
><A
HREF="#AEN89"
>SIP sessions</A
></DT
><DT
><A
HREF="#AEN97"
>Server behavior</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#AEN101"
>The oSIP Library</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN105"
>The goals</A
></DT
><DT
><A
HREF="#AEN110"
>The development level</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN112"
>The parser</A
></DT
><DT
><A
HREF="#AEN117"
>The state machines</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN120"
>The parser</A
></DT
><DT
><A
HREF="#AEN131"
>The transaction manager</A
></DT
><DT
><A
HREF="#AEN137"
>Who will benefit from oSIP</A
></DT
><DT
><A
HREF="#AEN140"
>Available ports</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#AEN143"
>The oSIP parser</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN145"
>files</A
></DT
><DT
><A
HREF="#AEN153"
>SIP-URL</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN155"
>Definition and purpose</A
></DT
><DT
><A
HREF="#AEN162"
>API for SIP-URL</A
></DT
><DT
><A
HREF="#AEN289"
>API for url_param_t and url_header_t</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN390"
>SIP headers</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN392"
>Definition and purpose</A
></DT
><DT
><A
HREF="#AEN398"
>Common API for all implemented header.</A
></DT
><DT
><A
HREF="#AEN482"
>Specific API for "To" header</A
></DT
><DT
><A
HREF="#AEN621"
>API for generic param</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN783"
>SIP messages</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN785"
>definition and purpose</A
></DT
><DT
><A
HREF="#AEN794"
>API for SIP message</A
></DT
><DT
><A
HREF="#AEN1270"
>MACROs</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1276"
>The parser HOW-TO.</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1279"
>Initialise the parser</A
></DT
><DT
><A
HREF="#AEN1284"
>Allocate a structure</A
></DT
><DT
><A
HREF="#AEN1292"
>create a URL and a Request-URI.</A
></DT
><DT
><A
HREF="#AEN1296"
>Add headers in a message</A
></DT
><DT
><A
HREF="#AEN1313"
>make a string from a structure</A
></DT
><DT
><A
HREF="#AEN1319"
>free resource in a structure</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1326"
>How to improve the parser performance</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#AEN1329"
>The oSIP state machines</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1331"
>files</A
></DT
><DT
><A
HREF="#AEN1339"
>Transaction and events</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1341"
>Definition and purpose of transaction</A
></DT
><DT
><A
HREF="#AEN1361"
>Definition and purpose of sipevent</A
></DT
><DT
><A
HREF="#AEN1378"
>API</A
></DT
><DT
><A
HREF="#AEN1595"
>The callbacks.</A
></DT
><DT
><A
HREF="#AEN1600"
>Useful MACROs.</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1604"
>The finite state machines HOW-TO</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN1611"
>Initialise the osip stack</A
></DT
><DT
><A
HREF="#AEN1616"
>Allocate and initialize an osip_t element</A
></DT
><DT
><A
HREF="#AEN1621"
>Send events to control transaction</A
></DT
><DT
><A
HREF="#AEN1625"
>Notes for proxy implementation</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1629"
>Build your own architecture</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN1639"
>Bibliography</A
></DT
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="SIP-PROTOCOL"
>Chapter 1. The SIP protocol</A
></H1
><P
>SIP is a signaling protocol used to initiate and control multimedia sessions. It is already published by IETF (www.ietf.org) as the rfc2543.</P
><P
>SIP is part of the IETF effort to bring telephony on the IP network.  It is about to become the standard used by the emerging IP telephony industry. As simple as the mail protocol, it may become as popular...</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SIP-MEDIA"
>SIP is independent of media</A
></H1
><P
>The traditional telephony was based on one media. Now, it's over. Your phone will be able to connect to a TV, to a camera, to others phones with different qualities and different codecs. Hopefully, SIP is independent of any media used by the applications. SIP is able to negotiate media used within sessions. Any multimedia application (games, distance learning application) can use SIP to set up sessions.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN42"
>SIP is independent of the transport layer</A
></H1
><P
>SIP is not tight to any transport protocol. This aspect will minimize efforts to interoperate with new third generation networks. Wireless phones are also concerned. A SIP stack perfectly fits the signaling needs of the new cellulars' generation.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN45"
>SIP is extensible</A
></H1
><P
>The rfc2543 defines 6 types of transaction (INVITE, BYE, CANCEL...). Those transactions are used to negotiate media, set up, modify and terminate calls. Many services are already provided this way but SIP is designed for extensibility and the transactional model can be reused (transparently for servers) by new type of transaction to create some supplementary services. Here is a list of possible services:</P
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>MESSAGE for instant messaging</TD
></TR
><TR
><TD
>SUBSCRIBE/NOTIFY for presence management</TD
></TR
><TR
><TD
>REFER for call-transfer management</TD
></TR
></TABLE
><P
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN52"
>SIP and end-user services</A
></H1
><P
><SPAN
CLASS="QUOTE"
>"SIP transparently supports name mapping and redirection services, allowing the implementation of ISDN and Intelligent Network telephony subscriber services. These facilities also enable personal mobility."</SPAN
></P
><P
>rfc2543.txt (Section 1.1)</P
><P
>SIP servers are used to locate users and distribute location (through urls) on demand. This way, end user agents have very minimal requirements and still have access to a wide variety of services.</P
><P
>Many extensions are already available as draft. Your can also add your personal phone capabilities and remain interoperable with existing servers.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN60"
>Chapter 2. SIP overview</A
></H1
><P
>This section does not intend to fully describe the RFC. It is a fast and incomplete overview of the protocol syntax and behavior.</P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN63"
>SIP syntax</A
></H1
><P
>SIP is a text protocol based on utf8 encoding. (making it more readable and easier to debug) SIP describes a syntax for SIP requests, URL, responses and their headers. The full syntax is available at <A
HREF="http://www.columbia.edu/~hgs/"
TARGET="_top"
>Columbia</A
> in an augmented BNF form.</P
><P
>The syntax is borrowed from the MAIL and HTTP syntax. 6 types of requests are defined by SIP. The basic available methods are:</P
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>INVITE</TD
></TR
><TR
><TD
>ACK</TD
></TR
><TR
><TD
>CANCEL</TD
></TR
><TR
><TD
>BYE</TD
></TR
><TR
><TD
>INFO</TD
></TR
><TR
><TD
>OPTIONS</TD
></TR
></TABLE
><P
></P
><P
>As you can see in the BNF definition of request (see rfc2543.txt section 3), SIP is not limited to this short list of methods and includes in its definition the extension-method token. Any other request can be handled by oSIP. NOTIFY and SUBSCRIBE are good examples of new possible methods. These ones are used specifically to provide presence capabilities to your SIP phone without much effort.</P
><P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 2-1. INVITE request</B
></P
><P
>INVITE requests are used to initiate and modify sessions. Here, cha from sipworld.net is calling jack at domain atosc.org. This request should be sent to the proxy server managing atosc.org, it will forward the call to jack at his real IP address.</P
><PRE
CLASS="PROGRAMLISTING"
>INVITE sip:jacK@atosc.org SIP/2.0
Via: SIP/2.0/UDP home.sipworld.org
To: sip:jacK@atosc.org
From: sip:cha@sipworld.org
Call-ID: 35778645354@home.sipworld.org
CSeq: 1 INVITE
Contact: sip:cha@home.sipworld.org
Content-type: application/sdp
Content-length: 267

v=0
o=user1 53655765 2353687637 IN IP4 128.3.4.5
s=Mbone Audio
i=Discussion of Mbone Engineering Issues
e=mbone@somewhere.com
c=IN IP4 128.3.4.5
t=0 0
m=audio 3456 RTP/AVP 0
a=rtpmap:0 PCMU/8000</PRE
></DIV
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN81"
>SIP transactions</A
></H1
><P
>In order to control sessions, SIP uses transactions. Transactions (INVITE, CANCEL, BYE...) usually result in a modification of a current session. Some other transactions (SUBSCRIBE, NOTIFY...) are not bound to a session. A transaction is composed of one request and its responses (many informational responses and one final response). The following headers: To, From, Call-ID and CSeq are used to identify messages within a transaction.</P
><P
>As SIP can use unreliable transport protocol (UDP is recommended on the IP network), SIP also defines retransmission rules for messages within a transaction.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 2-2. INVITE transaction</B
></P
><P
>This is the most basic call flow showing the initiation of a session. Only two SIP User Agents (UAC/UAS) are involved. (retransmissions are hidden)</P
><PRE
CLASS="PROGRAMLISTING"
>&#13;	          UAC1               UAS2

	  jacks    |   INVITE         |
	initiate a |-----------------&#62;|   Bob's
	  call     |                  | Phone starts
	           |       180 Ringing|   ringing
	           |&#60;-----------------|
	           |       180 Ringing|
        	   |&#60;-----------------|
	           |           200 OK |
	           |&#60;-----------------|
	           |   ACK            |
	           |-----------------&#62;|</PRE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN89"
>SIP sessions</A
></H1
><P
>Transactions are used by user agent as means to control sessions. A session is always initiated by an INVITE. SIP defines a large set of answer codes. A proxy may answer you the well known "404 User Not found" as for an HTTP error. Errors have different levels. A transaction can fail but still proposes new locations to try. Responses from class 3xx serve as redirection mechanism. 4xx, 5xx and 6xx responses are respectively reserved for client error, server error and global failure.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 2-3. A complete session</B
></P
><P
>First, both user agents must send a REGISTER to a registrar. In the following example, the proxy also support registration.</P
><P
>This session is initiated with an INVITE transaction to join jack at home.net. A redirection to jack's office is made by the redirect server of home.net. UA1 understands the redirection and sends a new INVITE towards the real User Agent (UA2) currently used by jack at office.atosc.org. UA2 first rings and jack accepts the call with a 200 OK response. After several minutes, jack and bob want to use their new cameras. The session is modified with an INVITE sent by jack to negotiate new parameters for video. The session is finally ended by bob.</P
><PRE
CLASS="PROGRAMLISTING"
>         BOB           home.net    Jack (atosc.org)
         UA1            PROXY            UA2
          | REGISTER      |               .
          |--------------&#62;|               .
          |        200 OK |               .
          |&#60;--------------|               .
          .               .               .
later...  .               .               .
          .               .               .
          .               |      REGISTER |
          .               |&#60;--------------|
          .               | 200 OK        |
          .               |--------------&#62;|
          .               .               .
later...  .               .               .
          | INVITE jack@home.net          .
          |--------------&#62;|               .
          |302 Moved temporarily            .
          |&#60;--------------|               .
          | ACK           |               .
          |--------------&#62;|               .
          | INVITE jack@office.atosc.org  |
          | audio                         |
          |------------------------------&#62;|
          |                  180 Ringing  |
          |&#60;------------------------------|
          |                  180 Ringing  |
          |&#60;------------------------------|
          |                       200 OK  |
          |&#60;------------------------------|
          | ACK jack@office.atosc.org     |
          |------------------------------&#62;|
          .                               .
later     .                               .
          .                               .
          |      INVITE bob@bob.home.net  |
          |      audio + video            |
          |&#60;------------------------------|
          |    200 OK                     |
          |------------------------------&#62;|
          |     ACK bob@bob.home.org      |
          |&#60;------------------------------|
          .                               .
later     .                               .
          .                               .
          | BYE jack@office.atosc.org     |
          |------------------------------&#62;|
          |                       200 OK  |
          |&#60;------------------------------|
          |                               |</PRE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN97"
>Server behavior</A
></H1
><P
>SIP defines behaviors for proxy, redirect and registrar server. For complete information, please read the RFC...</P
><P
>Usually, a user agent sends its requests to an outbound proxy. As users do not know the current location of their correspondent, they use for the sip url a username and a domain. The outbound proxy (where firewall capabilities can be inserted) uses DNS SRV RECORDS to find servers belonging to the requested domain. Once the server is found, the request is forwarded. This server is the inbound proxy of the correspondent. If the user is available, its application must have registered its location before, so the proxy is now able to forward the request to the real user location. On local network, other standards may be used to find user. (finger,...)</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN101"
>Chapter 3. The oSIP Library</A
></H1
><P
>Having a good knowledge of SIP is recommended for this section. If you plan to use SIP, you should read more carefully the rfc2543 from <A
HREF="http://www.ietf.org/"
TARGET="_top"
>ietf.org.</A
></P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN105"
>The goals</A
></H1
><P
>The oSIP project has started in July 2000. The first official and public release (0.5.0) was published in May 2001.</P
><P
>The oSIP library is at first a free software project. In the context of the third generation network, more and more telecom operators will use IP technology, the favorite land of Linux. One aspect of this evolution is that the future of Linux is highly dependent on the multimedia tools that will be available. oSIP, as a SIP implementation, will allow building interoperable registrar, user-agent (software phones), and proxy thus giving more chance to Linux to be part of the next generation telephony products.</P
><P
>But oSIP is not only targeted towards PC applications. oSIP is enough flexible and tiny to be used on small OS with low requirements. From the 0.7.0 release, the thread support is now optional and the design of the application is entirely chosen by the end-developer. oSIP will now perfectly fit cellulars or any embeded systems. oSIP is known to run on the real time OS VxWorks and other ports should be simple.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN110"
>The development level</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN112"
>The parser</A
></H2
><P
>oSIP now supports utf8 and the full SIP grammar. The release 0.7.0 contains a compliant SIP parser with minimal exceptions. Also, the new parser has just been released (25th of July 2001) and may have some bugs. Please report them to <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:osip@atosc.org"
>osip@atosc.org</A
>&#62;</TT
>, I'll fix them.</P
><FONT
COLOR="RED"
>To get more information, see next section</FONT
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN117"
>The state machines</A
></H2
><P
>The 4 finite state machines have been tested during weeks and have also been tested with around 30 products at the 8th SIPit in Cardiff (SIP Interoperability tests). They appear to be stable.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN120"
>The parser</A
></H1
><P
>oSIP contains a parser which is able to read and write any SIP message as described in the RFC. Currently oSIP is able to parse only a minimal set of headers such as Via, Call-ID, To, From, Contact, CSeq, Route, Record-Route, mime-version, Content-Type, and Content-Length. All other headers are stored as strings. Efforts will be done to support more headers.</P
><P
>By now, the SIP parser supports multiple attachments through the MIME format. (this part is new and remains untested)</P
><FONT
COLOR="RED"
>Unwanted behaviors may happen sometimes. Messages could be somewhat transformed after being analyzed by oSIP. oSIP cannot maintain reliability: (Nevertheless, oSIP remains fully SIP compliant)</FONT
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>the order of header</TD
></TR
><TR
><TD
>the presence of multiple headers on the same line</TD
></TR
><TR
><TD
>the presence of extra SPACEs between tokens</TD
></TR
><TR
><TD
>the presence of LWS (internal CRLF)</TD
></TR
><TR
><TD
>the presence of bracket in to,from,contact... headers</TD
></TR
></TABLE
><P
></P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN131"
>The transaction manager</A
></H1
><P
>oSIP presents an easy to use interface. Transactions are modeled through 4 finite state machines which is the core of the oSIP library. Each transaction uses a separate FIFO filled by external modules. Events are processed on demand by user. A set of dynamic callback registered by user allow the application to be informed of each transaction's evolution.</P
><P
><IMG
SRC="osip_model.png"
ALIGN="CENTER"></P
><P
>Building an application on the top of oSIP will require to build several modules as shown in the above graphic. First, you'll have to build a module to manage the transport facilities. This way, oSIP is independent from any transport layer. Then, you'll be required to build a module for timers management (a basic and far from excellent sample is provided). This module will be responsible of retransmission and will decide when the transaction context can be deleted safely. The third required module is the biggest part of the multimedia application. This modules will have to maintain and update the state of SIP sessions over transactions.</P
><P
>The transaction manager has been heavily tested and is already stable. Also, oSIP does not require much memory and runs fast. Since release 0.7.0, the library can be used either in multi-threaded mode or not!</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN137"
>Who will benefit from oSIP</A
></H1
><P
>oSIP offers a simple interface to add SIP capabilities in multimedia applications. Also, oSIP is not tight to any kind of SIP agents or OSs. You can build either end-user agents, stateless proxy and gateway. If you want to implement a proxy, please read "notes for proxy implementation" in the chapter called "the transaction manager".</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN140"
>Available ports</A
></H1
><P
>The library has been built with portability in mind and should be quickly usable on most posix systems. It has already been built under Solaris, HP unix and the RT OS VxWorks. GNU/Linux (2.2.16 and 2.4.7) has been used for initial developments.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN143"
>Chapter 4. The oSIP parser</A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN145"
>files</A
></H1
><P
><TT
CLASS="VARNAME"
>./libosip-x.x.x/parser </TT
>is the source directory for the SIP parser.</P
><P
><TT
CLASS="VARNAME"
>-losipparser-x.x.x </TT
>is the library containing the SIP parser</P
><P
><TT
CLASS="VARNAME"
>#include &#60;osip/smsg.h&#62; </TT
>is the include file describing the external SIP parser API</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN153"
>SIP-URL</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN155"
>Definition and purpose</A
></H2
><P
>URL are used to describe entirely a SIP entity: user, registrar, proxy have their own urls. oSIP uses the <SPAN
CLASS="TYPE"
>url_t</SPAN
> type definition in the request-uri and in the following headers: "to", "from", "contact", "route", and "record-route".</P
><P
>type definition of <SPAN
CLASS="TYPE"
>url_t</SPAN
>.</P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct _sipurl_t {
  char *scheme;
  char *username;
  char *password;
  char *host;
  char *port;
  list_t *url_params;
  list_t *url_headers;
} url_t ;</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN162"
>API for SIP-URL</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;smsg.h&#62;</PRE
><P
></P
></DIV
><H1
><A
NAME="FUNCTION.URL-INIT"
>url_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN167"
></A
><H2
>Name</H2
>url_init&nbsp;--&nbsp;Allocate and initialize the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN171"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_init</CODE
>(url_t **url);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-FREE"
>url_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN181"
></A
><H2
>Name</H2
>url_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>url</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN185"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_free</CODE
>(url_t ** url);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.URL-PARSE"
>url_parse</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN194"
></A
><H2
>Name</H2
>url_parse&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> and store results in <TT
CLASS="PARAMETER"
><I
>url</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN199"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_parse</CODE
>(url_t * url
char * field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-2CHAR"
>url_2char</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN210"
></A
><H2
>Name</H2
>url_2char&nbsp;--&nbsp;Allocate a string in <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> with the information stored in the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> parameter.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN215"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_2char</CODE
>(url_t *url
char **field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-CLONE"
>url_clone</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN226"
></A
><H2
>Name</H2
>url_clone&nbsp;--&nbsp;duplicate the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> element in a new dest element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN230"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_clone</CODE
>(url_t *url
url_t **dest);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-UPARAM-ADD"
>url_uparam_add</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN241"
></A
><H2
>Name</H2
>url_uparam_add&nbsp;--&nbsp;allocate and add a new url parameter in the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN245"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_uparam_add</CODE
>(url_t *url
char *pname
char *pvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-UHEADER-ADD"
>url_uheader_add</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN257"
></A
><H2
>Name</H2
>url_uheader_add&nbsp;--&nbsp;allocate and add a new url header element in the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN261"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_uheader_add</CODE
>(url_t *url
char *hname
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-UPARAM-GETBYNAME"
>url_uparam_getbyname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN273"
></A
><H2
>Name</H2
>url_uparam_getbyname&nbsp;--&nbsp;Find a url parameter with <TT
CLASS="PARAMETER"
><I
>pname</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN278"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_uparam_getbyname</CODE
>(url_t *url
char *pname
url_param_t **url_param);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN289"
>API for url_param_t and url_header_t</A
></H2
><P
>url_param_t and url_header_t are data types used inside a SIP-URL. Methods are provided to allocate, free or clone resources.</P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>Important: </B
>The API is the same for url parameters and header parameters. You just have to replace "url_" with "header_".</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-1. type definitions of url_param_t and header_param_t.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>  typedef struct _url_param_t {
    char *pname;
    char *pvalue;
  } url_param_t;

  typedef struct _url_header_t {
    char *hname;
    char *hvalue;
  } url_header_t;</PRE
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-INIT"
>url_param_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN298"
></A
><H2
>Name</H2
>url_param_init&nbsp;--&nbsp;Allocate and initialize the <TT
CLASS="PARAMETER"
><I
>url_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN302"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int url_param_init</CODE
>(url_param_t **url_param);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-FREE"
>url_param_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN312"
></A
><H2
>Name</H2
>url_param_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>url_param</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN316"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_param_free</CODE
>(url_param_t **url_param);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-SET"
>url_param_set</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN325"
></A
><H2
>Name</H2
>url_param_set&nbsp;--&nbsp;Set <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>url_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN331"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_param_set</CODE
>(url_param_t *url_param
char *pname
char *pvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-FREELIST"
>url_param_freelist</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN343"
></A
><H2
>Name</H2
>url_param_freelist&nbsp;--&nbsp;free resources contained in the list <TT
CLASS="PARAMETER"
><I
>url_params</I
></TT
> elements.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN347"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_param_freelist</CODE
>(list_t *url_params);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-ADD"
>url_param_add</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN356"
></A
><H2
>Name</H2
>url_param_add&nbsp;--&nbsp;add <TT
CLASS="PARAMETER"
><I
>url_param</I
></TT
> in the list <TT
CLASS="PARAMETER"
><I
>url_params</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN361"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_param_add</CODE
>(list_t *url_params
char *pname
char *pvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.URL-PARAM-GETBYNAME"
>url_param_getbyname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN373"
></A
><H2
>Name</H2
>url_param_getbyname&nbsp;--&nbsp;Find the <TT
CLASS="PARAMETER"
><I
>url_param</I
></TT
> with <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> in the list <TT
CLASS="PARAMETER"
><I
>url_params</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN379"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void url_param_getbyname</CODE
>(list_t *url_params
char *pname
url_param_t **url_param);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN390"
>SIP headers</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN392"
>Definition and purpose</A
></H2
><P
>The rfc2543 defines around 40 headers. SIP Messages are mainly composed of a list of headers. This first part documents the API to create, allocate, parse and print the SIP headers elements. The second one shows that headers also have a extended API only applicable for one type of header. The extended API presented below is for the "To" header. Nevertheless, the extended API for the "To" header is also valid for the "From", "Contact", "Route" and "Record-Route" headers.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-2. type definition of to_t</B
></P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct _to_t {
  char *displayname;
  url_t *url;
  list_t *gen_params;
} to_t;</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN398"
>Common API for all implemented header.</A
></H2
><P
>The SIP parser can parse entirely the following headers: Via, To, From, CSeq, Call-Id, Contact, Route, Record-Route, Content-Type, Content-length, Mime-Version. The other headers are accessible as strings through a special API.</P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>Important: </B
>This API presented below is applicable for all known headers: Simply replace "to_" by one of the following list: "via_", "to_", "from_", "contact", "route_", "record_route_", "content_type_", "content_length_", "mime_version_", "cseq_", "call_id_"</P
></BLOCKQUOTE
></DIV
><FONT
COLOR="RED"
>If you are interested in developing new headers, you just have to re-use the API proposed below. Contributions are welcomed...</FONT
><P
>As an example, the following methods concern the API to manipulate a <SPAN
CLASS="TYPE"
>to_t</SPAN
> structure.</P
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;smsg.h&#62;</PRE
><P
></P
></DIV
><H1
><A
NAME="FUNCTION.TO-INIT"
>to_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN409"
></A
><H2
>Name</H2
>to_init&nbsp;--&nbsp;Allocate and initialize the structure <TT
CLASS="PARAMETER"
><I
>to</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN413"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_init</CODE
>(to_t **to);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.TO-FREE"
>to_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN423"
></A
><H2
>Name</H2
>to_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>to</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN427"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void to_free</CODE
>(to_t **to);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-PARSE"
>to_parse</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN436"
></A
><H2
>Name</H2
>to_parse&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> and store results in <TT
CLASS="PARAMETER"
><I
>to</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN441"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_parse</CODE
>(to_t *to
char *field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.TO-2CHAR"
>to_2char</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN452"
></A
><H2
>Name</H2
>to_2char&nbsp;--&nbsp;Allocate a string in <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> with the information stored in the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> parameter.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN457"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_2char</CODE
>(to_t *to
char **field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.TO-CLONE"
>to_clone</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN468"
></A
><H2
>Name</H2
>to_clone&nbsp;--&nbsp;duplicate the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element in a new dest element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN472"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_clone</CODE
>(to_t *to
to_t **dest);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN482"
>Specific API for "To" header</A
></H2
><P
>In addition to the common API shared by all known implemented header, there is a specific API valid only for each header. The following methods concern the "To" header.</P
><H1
><A
NAME="FUNCTION.TO-SETDISPLAYNAME"
>to_setdisplayname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN486"
></A
><H2
>Name</H2
>to_setdisplayname&nbsp;--&nbsp;set the display name in the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN490"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void to_setdisplayname</CODE
>(to_t *to
char *value);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-GETDISPLAYNAME"
>to_getdisplayname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN500"
></A
><H2
>Name</H2
>to_getdisplayname&nbsp;--&nbsp;return the display name from the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN504"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *to_getdisplayname</CODE
>(to_t *to);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-SETURL"
>to_seturl</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN513"
></A
><H2
>Name</H2
>to_seturl&nbsp;--&nbsp;set the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN518"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void to_seturl</CODE
>(to_t *to
url_t *url);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-GETURL"
>to_geturl</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN528"
></A
><H2
>Name</H2
>to_geturl&nbsp;--&nbsp;return the <TT
CLASS="PARAMETER"
><I
>url</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN533"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>url_t *to_geturl</CODE
>(to_t *to);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-PARAM-ADD"
>to_param_add</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN542"
></A
><H2
>Name</H2
>to_param_add&nbsp;--&nbsp;add a <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN547"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_param_add</CODE
>(to_t *to
char *name
char *value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.TO-PARAM-GET"
>to_param_get</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN559"
></A
><H2
>Name</H2
>to_param_get&nbsp;--&nbsp;return the <TT
CLASS="PARAMETER"
><I
>param</I
></TT
> at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN565"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_param_get</CODE
>(to_t *to
int pos
generic_param_t **gp);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-GETTAG"
>to_gettag</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN576"
></A
><H2
>Name</H2
>to_gettag&nbsp;--&nbsp;return the value associated with the tag parameter from the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN580"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void to_gettag</CODE
>(to_t *to
generic_param_t **dest);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-SETTAG"
>to_settag</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN590"
></A
><H2
>Name</H2
>to_settag&nbsp;--&nbsp;set the <TT
CLASS="PARAMETER"
><I
>tag</I
></TT
> parameter int the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN595"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void to_settag</CODE
>(to_t *to
char *tag);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TO-PARAM-GETBYNAME"
>to_param_getbyname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN605"
></A
><H2
>Name</H2
>to_param_getbyname&nbsp;--&nbsp;get the parameter with <TT
CLASS="PARAMETER"
><I
>pname</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN610"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int to_param_getbyname</CODE
>(to_t *to
char *pname
generic_param_t **dest);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN621"
>API for generic param</A
></H2
><P
>Generic parameter are components of many headers such as To, From, Contact, Route, Record-Route, and Content-Type.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-3. The To header has a list of generic_param_t</B
></P
><PRE
CLASS="PROGRAMLISTING"
>  typedef struct _generic_param_t {
      char *pname;
      char *pvalue;
  } generic_param_t;

  /* to, from and contact headers are defined as below */ 
  typedef struct _to_t {
      char *displayname;
      url_t *url;
      list_t *gen_params;
  }</PRE
></DIV
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-4. A To header with the "tag" parameter</B
></P
><PRE
CLASS="PROGRAMLISTING"
>  to: "jack" &#60;sip:atosc.org&#62;;tag=ae56fr-dz-23</PRE
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-INIT"
>generic_param_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN631"
></A
><H2
>Name</H2
>generic_param_init&nbsp;--&nbsp;Allocate and initialize the structure <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN635"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int generic_param_init</CODE
>(generic_param_t * gen_param);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-FREE"
>generic_param_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN645"
></A
><H2
>Name</H2
>generic_param_free&nbsp;--&nbsp;free resources contained in the structure <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN649"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void generic_param_free</CODE
>(generic_param_t *gen_param);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-SET"
>generic_param_set</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN658"
></A
><H2
>Name</H2
>generic_param_set&nbsp;--&nbsp;Set <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN664"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void generic_param_set</CODE
>(generic_param_t *gen_param
char *pname
char *pvalue);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-GETNAME"
>generic_param_getname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN675"
></A
><H2
>Name</H2
>generic_param_getname&nbsp;--&nbsp;Get <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN680"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *generic_param_getname</CODE
>(generic_param_t *gen_param);</CODE
></P
><P
></P
></DIV
><P
>on error, return NULL.</P
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-SETNAME"
>generic_param_setname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN690"
></A
><H2
>Name</H2
>generic_param_setname&nbsp;--&nbsp;set <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN695"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void generic_param_setname</CODE
>(generic_param_t *gen_param
char *pname);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-GETVALUE"
>generic_param_getvalue</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN705"
></A
><H2
>Name</H2
>generic_param_getvalue&nbsp;--&nbsp;Get <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN710"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>char *generic_param_getvalue</CODE
>(generic_param_t *gen_param);</CODE
></P
><P
></P
></DIV
><P
>on error, return NULL.</P
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-SETVALUE"
>generic_param_setvalue</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN720"
></A
><H2
>Name</H2
>generic_param_setvalue&nbsp;--&nbsp;set <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> in the <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN725"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void generic_param_setvalue</CODE
>(generic_param_t *gen_param
char *pvalue);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-ADD"
>generic_param_add</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN735"
></A
><H2
>Name</H2
>generic_param_add&nbsp;--&nbsp;Allocate a new generic param with <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> and <TT
CLASS="PARAMETER"
><I
>value</I
></TT
> and add the element in the list <TT
CLASS="PARAMETER"
><I
>gen_params</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN741"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int generic_param_add</CODE
>(list_t *gen_params
char *name
char *value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-GETBYNAME"
>generic_param_getbyname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN753"
></A
><H2
>Name</H2
>generic_param_getbyname&nbsp;--&nbsp;find element containing <TT
CLASS="PARAMETER"
><I
>name</I
></TT
> from the list <TT
CLASS="PARAMETER"
><I
>gen_params</I
></TT
> and return it in <TT
CLASS="PARAMETER"
><I
>gen_param</I
></TT
> .</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN759"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int generic_param_getbyname</CODE
>(list_t *gen_params
char *name
generic_param_t **gen_param);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.GENERIC-PARAM-FREELIST"
>generic_param_freelist</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN771"
></A
><H2
>Name</H2
>generic_param_freelist&nbsp;--&nbsp;free resources contained in the list <TT
CLASS="PARAMETER"
><I
>gen_params</I
></TT
> elements.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN775"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void generic_param_freelist</CODE
>(list_t *gen_params);</CODE
></P
><P
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN783"
>SIP messages</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN785"
>definition and purpose</A
></H2
><P
>The messages are based at this level on three parts. The first line is either the request-uri for requests or the status code for responses. This first line corresponds to the first attribute of oSIP: startline_t. The second valuable part of a SIP message is a list of headers. The last attribute (list of body) is a possible list of attachments found in the message.</P
><P
>Currently this structure <SPAN
CLASS="TYPE"
>sip_t</SPAN
> is not complete. All other header than "From", "To", "Call-Id", "CSeq", "via", "contact", "route", "record-route", mime-version", "content-type" and "content-length" are stored as string in a list of generic headers. This structure will be completed while improving the parser capabilities.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-5. type definition for <SPAN
CLASS="TYPE"
>sip_t</SPAN
>.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct _sip_t {
  /* Start-Line definition */
  char *sipversion;
  /* req */
  osip_uri_t *rquri;
  char *sipmethod;
  /* resp */
  char *statuscode;
  char *reasonphrase;
  /* End of Start-Line definition */

  /* for all header fully implemented by oSIP */
  from_t           *from;
  to_t             *to;
  call_id_t        *call_id;
  cseq_t           *cseq;
  list_t           *vias;
  list_t           *contacts;
  list_t           *record_routes;
  list_t           *routes;
  content_type_t   *content_type;
  content_length_t *contentlength;
  mime_version_t   *mime_version;

  /* for all other headers */
  list_t           *headers;

  /* for all attachments */
  list_t           *bodies;

} sip_t;</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN794"
>API for SIP message</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;smsg.h&#62;</PRE
><P
></P
></DIV
><H1
><A
NAME="FUNCTION.MSG-INIT"
>msg_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN799"
></A
><H2
>Name</H2
>msg_init&nbsp;--&nbsp;Allocate and initialize the structure <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN803"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_init</CODE
>(sip_t **msg);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-FREE"
>osip_message_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN813"
></A
><H2
>Name</H2
>osip_message_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN817"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void osip_message_free</CODE
>(sip_t **msg);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.MSG-PARSE"
>msg_parse</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN826"
></A
><H2
>Name</H2
>msg_parse&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> and store results in <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN831"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_parse</CODE
>(sip_t *msg
char *field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-2CHAR"
>msg_2char</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN842"
></A
><H2
>Name</H2
>msg_2char&nbsp;--&nbsp;Allocate a string in <TT
CLASS="PARAMETER"
><I
>field_value</I
></TT
> with the information stored in the <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
> parameter.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN847"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_2char</CODE
>(sip_t *msg
char **field_value);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-CLONE"
>msg_clone</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN858"
></A
><H2
>Name</H2
>msg_clone&nbsp;--&nbsp;duplicate the <TT
CLASS="PARAMETER"
><I
>msg</I
></TT
> element in a new dest element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN862"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_clone</CODE
>(sip_t *msg
sip_t **dest);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETHEADER"
>msg_setheader</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN873"
></A
><H2
>Name</H2
>msg_setheader&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and add a new header in <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN878"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setheader</CODE
>(sip_t *sip
char *hname
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETHEADER"
>msg_getheader</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN890"
></A
><H2
>Name</H2
>msg_getheader&nbsp;--&nbsp;set in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> the header at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN896"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_getheader</CODE
>(sip_t *sip
int pos
header_t **header);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-HEADER-GETBYNAME"
>msg_header_getbyname</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN908"
></A
><H2
>Name</H2
>msg_header_getbyname&nbsp;--&nbsp;find the first header (after index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
>) with <TT
CLASS="PARAMETER"
><I
>hname</I
></TT
> from the list of header in the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN914"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_header_getbyname</CODE
>(char *hname
sip_t *sip
int pos
header_t **dest);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETCALL-ID"
>msg_setcall_id</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN927"
></A
><H2
>Name</H2
>msg_setcall_id&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the call_id attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN932"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setcall_id</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETCALL-ID"
>msg_getcall_id</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN943"
></A
><H2
>Name</H2
>msg_getcall_id&nbsp;--&nbsp;return the call_id attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN947"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>call_id_t *msg_getcall_id</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETCSEQ"
>msg_setcseq</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN957"
></A
><H2
>Name</H2
>msg_setcseq&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the cseq attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN962"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setcseq</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETCSEQ"
>msg_getcseq</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN973"
></A
><H2
>Name</H2
>msg_getcseq&nbsp;--&nbsp;return the cseq attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN977"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>cseq_t *msg_getcseq</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETCONTACT"
>msg_setcontact</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN987"
></A
><H2
>Name</H2
>msg_setcontact&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and add a new contact attribute in the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN992"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setcontact</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETCONTACT"
>msg_getcontact</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1003"
></A
><H2
>Name</H2
>msg_getcontact&nbsp;--&nbsp;set in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> the contact at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1009"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_getcontact</CODE
>(sip_t *sip
int pos
contact_t **contact);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETFROM"
>msg_setfrom</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1021"
></A
><H2
>Name</H2
>msg_setfrom&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the from attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1026"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setfrom</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETFROM"
>msg_getfrom</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1037"
></A
><H2
>Name</H2
>msg_getfrom&nbsp;--&nbsp;return the from attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1041"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>from_t *msg_getfrom</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETTO"
>msg_setto</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1051"
></A
><H2
>Name</H2
>msg_setto&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the to attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1056"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setto</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETTO"
>msg_getto</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1067"
></A
><H2
>Name</H2
>msg_getto&nbsp;--&nbsp;return the <TT
CLASS="PARAMETER"
><I
>to</I
></TT
> attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1072"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>to_t *msg_getto</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETVIA"
>msg_setvia</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1082"
></A
><H2
>Name</H2
>msg_setvia&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and add a new via in <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1087"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setvia</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETVIA"
>msg_getvia</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1098"
></A
><H2
>Name</H2
>msg_getvia&nbsp;--&nbsp;set in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> the via at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1104"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_getvia</CODE
>(sip_t *sip
int pos
via_t **via);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETRECORD-ROUTE"
>msg_setrecord_route</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1116"
></A
><H2
>Name</H2
>msg_setrecord_route&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and add a new record_route in the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1121"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setrecord_route</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETRECORD-ROUTE"
>msg_getrecord_route</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1132"
></A
><H2
>Name</H2
>msg_getrecord_route&nbsp;--&nbsp;set in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> the record_route at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1138"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_getrecord_route</CODE
>(sip_t *sip
int pos
record_route_t **record_route);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETROUTE"
>msg_setroute</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1150"
></A
><H2
>Name</H2
>msg_setroute&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and add a new route in the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1155"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setroute</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETROUTE"
>msg_getroute</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1166"
></A
><H2
>Name</H2
>msg_getroute&nbsp;--&nbsp;set in <TT
CLASS="PARAMETER"
><I
>dest</I
></TT
> the route at index <TT
CLASS="PARAMETER"
><I
>pos</I
></TT
> from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1172"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_getroute</CODE
>(sip_t *sip
int pos
route_t **route);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETCONTENT-LENGTH"
>msg_setcontent_length</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1184"
></A
><H2
>Name</H2
>msg_setcontent_length&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the content_length attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1189"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setcontent_length</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETCONTENT-LENGTH"
>msg_getcontent_length</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1200"
></A
><H2
>Name</H2
>msg_getcontent_length&nbsp;--&nbsp;return the content_length attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1204"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>content_length_t * msg_getcontent_length</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETCONTENT-TYPE"
>msg_setcontent_type</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1213"
></A
><H2
>Name</H2
>msg_setcontent_type&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the content_type attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1218"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setcontent_type</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETCONTENT-TYPE"
>msg_getcontent_type</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1229"
></A
><H2
>Name</H2
>msg_getcontent_type&nbsp;--&nbsp;return the content_type attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1233"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>content_type_t * msg_getcontent_type</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.MSG-SETMIME-VERSION"
>msg_setmime_version</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1242"
></A
><H2
>Name</H2
>msg_setmime_version&nbsp;--&nbsp;Parse <TT
CLASS="PARAMETER"
><I
>hvalue</I
></TT
>, allocate and set the mime_version attribute of the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1247"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int msg_setmime_version</CODE
>(sip_t *sip
char *hvalue);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.MSG-GETMIME-VERSION"
>msg_getmime_version</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1258"
></A
><H2
>Name</H2
>msg_getmime_version&nbsp;--&nbsp;return the mime_version attribute from the <TT
CLASS="PARAMETER"
><I
>sip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1262"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>mime_version_t * msg_getmime_version</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1270"
>MACROs</A
></H2
><P
>Other helpful MACROs are defined. They are used to test characteristics of messages such as the type of a message, the method of a request and the status code of a response.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-6. List of MACROs</B
></P
><PRE
CLASS="PROGRAMLISTING"
>/* a few MACROS to ease readability of code */
#define MSG_IS_RESPONSE(resp)     (resp-&#62;strtline-&#62;statuscode!=NULL)
#define MSG_IS_REQUEST(req)       (req-&#62;strtline-&#62;statuscode==NULL)

#define MSG_IS_INVITE(msg)  (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"INVITE",6))
#define MSG_IS_ACK(msg)     (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"ACK",6))
#define MSG_IS_BYE(msg)     (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"BYE",6))
#define MSG_IS_REGISTER(msg) (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"REGISTER",6))
#define MSG_IS_CANCEL(msg)  (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"CANCEL",6))
#define MSG_IS_OPTIONS(msg) (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"OPTIONS",6))
#define MSG_IS_INFO(msg)    (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"INFO",6))
#define MSG_IS_PRACK(msg)   (0==strncmp(msg-&#62;strtline-&#62;sipmethod,"PRACK",6))

#define MSG_IS_STATUS_1XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"1",1))
#define MSG_IS_STATUS_2XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"2",1))
#define MSG_IS_STATUS_3XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"3",1))
#define MSG_IS_STATUS_4XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"4",1))
#define MSG_IS_STATUS_5XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"5",1))
#define MSG_IS_STATUS_6XX(msg)    (0==strncmp(msg-&#62;strtline-&#62;statuscode,"6",1))
#define MSG_TEST_CODE(resp, code) (resp-&#62;strtline-&#62;statuscode!=NULL \
				   &#38;&#38; code==(int)satoi(resp-&#62;strtline-&#62;statuscode))
#define MSG_IS_RESPONSEFOR(resp,requestname) \
                                  (0==strcmp(resp-&#62;cseq-&#62;method,requestname))</PRE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1276"
>The parser HOW-TO.</A
></H1
><P
>Building a message is not a complex task and does not require to be a C expert. Nevertheless, it requires you to be a SIP expert! The document describing SIP (rfc2543.txt) provides all you need to build correct requests and response. You will have to know which header MUST be included ("To", "From", "Call-ID", "Cseq" are the most common...), which header MUST NOT be included, and which header MAY appear in the message.  </P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1279"
>Initialise the parser</A
></H2
><P
>The oSIP parser need to be initialised at run time. This is done by first calling the following method before using the oSIP parser. (This method MUST only be called once.)</P
><P
>int <FONT
COLOR="RED"
>parser_init()</FONT
>;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1284"
>Allocate a structure</A
></H2
><P
>oSIP has a standard approach to request allocation of structures. For each SIP related one, (like <SPAN
CLASS="TYPE"
>sip_t</SPAN
>, or <SPAN
CLASS="TYPE"
>from_t</SPAN
>) a method "xxxx_init()" exists and MUST be used to request allocation. Using this method with the correspondent "xxxx_free()" allows a competitive memory management thus avoiding as many memory leaks as possible.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-7. allocation of sip_t and url_t.</B
></P
><PRE
CLASS="PROGRAMLISTING"
> sip_t  *msg;
 msg_init(&#38;msg);

 osip_message_free(msg);
 free(msg);

 url_t *url;
 url_init(&#38;url);

 url_free(url);
 free(url);</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1292"
>create a URL and a Request-URI.</A
></H2
><P
>The following code is used to build a request line for an INVITE message. This line will be: "INVITE sip:jack@atosc.org SIP/2.0".</P
><PRE
CLASS="PROGRAMLISTING"
> /* make a request line. */
 url_t  *uri;
 url_init(&#38;uri);
 url_setscheme(url,sstrdup("sip"));
 url_setuserinfo(url,sstrdup("jack"));
 url_sethost(url,sstrdup("atosc.org"));

 msg_setmethod(msg,sstrdup("INVITE"));
 msg_seturi(msg,uri);
 msg_setversion(msg,sstrdup("2.0"));</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1296"
>Add headers in a message</A
></H2
><P
>This example shows the code required to allocate headers and add each of them in the <SPAN
CLASS="TYPE"
>sip_t</SPAN
> structure. You should take a look at the RFC when building messages.</P
><P
>For INVITE requests,the following headers are mandatory:</P
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>Via</TD
></TR
><TR
><TD
>CSeq</TD
></TR
><TR
><TD
>Call-Id</TD
></TR
><TR
><TD
>To</TD
></TR
><TR
><TD
>From</TD
></TR
><TR
><TD
>Contact</TD
></TR
><TR
><TD
>Content-length</TD
></TR
><TR
><TD
>Content-Type (if a body is attached)</TD
></TR
></TABLE
><P
></P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-8. Add header</B
></P
><PRE
CLASS="PROGRAMLISTING"
> {
  url_t    *url;
  to_t     *to;
  url_init(&#38;url);
  url_setusername(url,sstrdup("jack"));
  url_sethost(url,sstrdup("atosc.org"));

  to_init(&#38;to);
  to_seturl(to,url);
  to_setdisplayname(to,sstrdup("jack..."));

  msg_setto(msg, to);
 }

  /* the same API is available for the from_t structure */
 {
  from_t   *from;
  /* allocate a url_t */
  url_init(&#38;url);
  url_setusername(url,sstrdup("cha"));
  url_sethost(url,sstrdup("anywhere.org"));

  /* allocate a from_t */
  from_init(&#38;from);
  from_seturl(from,url);
  from_setdisplayname(from,sstrdup("My love"));
  from_set_tag(from,sstrdup("a48a"));

  msg_setfrom(msg, from);
 }

 {
  via_t    *via;
  via_init(&#38;via);

  via_setversion(via,sstrdup("2.0"));
  via_setprotocol(via,sstrdup("UDP"));
  via_sethost(via,sstrdup("137.137.137.137"));
  via_set_branch(via,sstrdup("branch"),sstrdup("a7c6a8dlze.1"));

  msg_setvia(msg, via);
 }

 {
  cseq_t   *cseq;
  cseq_init(&#38;cseq);
  ...

  msg_setcseq(msg, cseq);
 }

 {
  callid_t *callid;
  callid_init(&#38;callid);

  callid_setnumber(callid,sstrdup("f81d4"));
  callid_sethost(callid,sstrdup("foo.atosc.org"));

  msg_setcallid(msg, callid);
 }

 /* this API can also be used, but it is much more time consuming! */
 msg_setcontact(msg,"sip:jacK@office.atosc.org");

 /* Let's add some headers */
 msg_setheader(msg,sstrdup("SuBjecT"),sstrdup("Need support for oSIP!"));

 /* add a body */
 msg_setbody(msg,"v=0\r\no=user1 53655765 2353687637 IN IP4 128.3.4.5\r\ns=Mbone Audio\r\ni=Discussion of Mbone Engineering Issues\r\ne=mbone@somewhere.com\r\nc=IN IP4 128.3.4.5\r\nt=0 0\r\nm=audio 3456 RTP/AVP 0\r\na=rtpmap:0 PCMU/8000\r\n");</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1313"
>make a string from a structure</A
></H2
><P
>For sip_t like for the structure used for the headers (to_t, from_t, call_id_t...), a method exist to retrieve printed version of the element.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-9. Method xxxx_2char</B
></P
><PRE
CLASS="PROGRAMLISTING"
>  char *astring;
  astring = sip_2char(msg);
  free(astring);</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1319"
>free resource in a structure</A
></H2
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 4-10. Method xxxx_free</B
></P
><P
>This is how you must free all memory.</P
><PRE
CLASS="PROGRAMLISTING"
> sip_free(msg);
 free(msg);</PRE
></DIV
><P
>The parser may sometimes be too much tolerant. It will accept silently some of your mistakes. As an example, the parser should accept a display name (for a "To" header) with a comma inside. The developer MUST enclose the string between quotes. To keep the application interoperable, please always keep an eye on the rfc and control every characters you put in SIP message.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1326"
>How to improve the parser performance</A
></H1
><P
>To improve stack performance, you can configure the parser at link time by choosing which headers must ALWAYS be completely decoded. (It could also be possible at run time with minimal work!). You may find this useful in terms of performance when implementing proxies.</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN1329"
>Chapter 5. The oSIP state machines</A
></H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN1331"
>files</A
></H1
><P
><TT
CLASS="VARNAME"
>./libosip-x.x.x/fsm </TT
>is the source directory for the SIP finite state machines.</P
><P
><TT
CLASS="VARNAME"
>-losipfsm-x.x.x </TT
>is the library containing the SIP finite state machines</P
><P
><TT
CLASS="VARNAME"
>#include &#60;osip/osip.h&#62; </TT
>is the include file describing the external SIP parser API</P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1339"
>Transaction and events</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN1341"
>Definition and purpose of transaction</A
></H2
><P
>Transactions are used to store the context of one "SIP transactions" as defined in the rfc2543. oSIP uses the <SPAN
CLASS="TYPE"
>transaction_t</SPAN
> internally so you probably don't need to understand each attribute.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 5-1. oSIP model for transactions</B
></P
><P
>Managing a transaction consists in building modules that can send events to control the transaction </P
><PRE
CLASS="PROGRAMLISTING"
>       User module
        +------------+
        |            |
        +------------+
            |        msg to send
            +--------------------+        Transaction
       Timer module              |         contexts
        +------------+           |
        |            |           |        +----------+
        +------------+           +-------&#62;| TRANSAC. |
            |        timeout evt |        |    1     |
            +--------------------+        +----------+
       Transport module          |
        +------------+           |        +----------+
        |            |           +-------&#62;| TRANSAC. |
        +------------+           |        |    2     |
            |      incoming msg  |        +----------+
            +--------------------+</PRE
></DIV
><P
>The attribute <TT
CLASS="VARNAME"
>your_instance</TT
> is not used by oSIP. You can use it to store a pointer on your own context.</P
><P
>You can use the <TT
CLASS="VARNAME"
>transactionid</TT
> as a unique id for the transaction.</P
><P
><TT
CLASS="VARNAME"
>transactionff</TT
> is a FIFO used to receive all events (sipevent_t) which concern this transaction.</P
><P
>The <TT
CLASS="VARNAME"
>proxy</TT
> attribute give the host and port to be used for requests. (all requests will be forced to go to the proxy whatever the request-uri contains.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 5-2. type definition of <SPAN
CLASS="TYPE"
>transaction_t</SPAN
>.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct _transaction_t {
  void *your_instance;       /* add whatever you want here.       */
  int transactionid;         /* simple id used to identify the tr.*/
  fifo_t *transactionff;     /* events must be added in this FIFO */
  url_t *proxy;              /* url used to send requests        */    

  from_t    *from;           /* CALL-LEG definition */
  to_t      *to;
  call_id_t *callid;
  cseq_t    *cseq;
  sip_t *lastrequest;        /* last request received or sent     */
  sip_t *lastresponse;       /* last response received or sent    */

  state_t state;             /* state of transaction              */
  statemachine_t *statemachine; /* state-machine of transaction   */

  time_t birth_time;         /* birth_date of transaction         */
  time_t completed_time;     /* end   date of transaction         */
  int retransmissioncounter; /* facilities for internal timer     */

  void *config;              /* transaction is managed by config */
                             /* of type osip_t */
} transaction_t;</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1361"
>Definition and purpose of sipevent</A
></H2
><P
>sipevents objects are used to control the context of one "SIP transaction" element. There is 3 types of SIP events for the finite state machines:</P
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>incoming SIP messages. (requests and responses)</TD
></TR
><TR
><TD
>outgoing SIP messages. (requests and responses)</TD
></TR
><TR
><TD
>timers events. (retransmissions and context removal)</TD
></TR
></TABLE
><P
></P
><P
>The attribute <TT
CLASS="VARNAME"
>type</TT
> always contains the type of the event.</P
><P
><TT
CLASS="VARNAME"
>transactionid</TT
> is now for internal use.</P
><P
>When the event is a SIP message, <TT
CLASS="VARNAME"
>sip</TT
> is the parsed message.</P
><DIV
CLASS="EXAMPLE"
><P
><B
>Example 5-3. type definition of <SPAN
CLASS="TYPE"
>sipevent_t</SPAN
>.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>typedef struct _sipevent_t {
  type_t type;
  int transactionid;
  sip_t *sip;
} sipevent_t;</PRE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1378"
>API</A
></H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><PRE
CLASS="FUNCSYNOPSISINFO"
>#include &#60;osip.h&#62;</PRE
><P
></P
></DIV
><H1
><A
NAME="FUNCTION.OSIP-INIT"
>osip_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1383"
></A
><H2
>Name</H2
>osip_init&nbsp;--&nbsp;Allocate and initialize the <TT
CLASS="PARAMETER"
><I
>osip</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1387"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int osip_init</CODE
>(osip_t **osip);</CODE
></P
><P
></P
></DIV
><P
>on success, return 0.</P
></DIV
><H1
><A
NAME="FUNCTION.OSIP-FREE"
>osip_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1397"
></A
><H2
>Name</H2
>osip_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>osip</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1401"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void osip_free</CODE
>(osip_t *osip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-INIT-PROXY"
>osip_init_proxy</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1410"
></A
><H2
>Name</H2
>osip_init_proxy&nbsp;--&nbsp;set the default proxy to be used for all transactions related to <TT
CLASS="PARAMETER"
><I
>osip</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1414"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void osip_init_proxy</CODE
>(osip_t *osip
url_t *url);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-EXECUTE"
>osip_execute</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1424"
></A
><H2
>Name</H2
>osip_execute&nbsp;--&nbsp;consumes all SIP events from the list of transactions contained in <TT
CLASS="PARAMETER"
><I
>osip</I
></TT
>. (This method is only designed for NON-MULTI THREADED application.)</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1428"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int osip_execute</CODE
>(osip_t *osip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-DISTRIBUTE-EVENT"
>osip_distribute_event</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1437"
></A
><H2
>Name</H2
>osip_distribute_event&nbsp;--&nbsp;distribute a SIP event (message) in the right FIFO of <TT
CLASS="PARAMETER"
><I
>osip</I
></TT
> This method has to be used for incoming message.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1441"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>transaction_t *osip_distribute_event</CODE
>(osip_t *osip
sipevent_t *se);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-PARSE"
>osip_parse</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1451"
></A
><H2
>Name</H2
>osip_parse&nbsp;--&nbsp;parse <TT
CLASS="PARAMETER"
><I
>buf</I
></TT
> and create an SIP incoming message event.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1455"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>sipevent_t *osip_parse</CODE
>(char *buf);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-NEW-EVENT"
>osip_new_event</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1464"
></A
><H2
>Name</H2
>osip_new_event&nbsp;--&nbsp;create a new SIP event with attributes <SPAN
CLASS="TYPE"
>type</SPAN
> and <SPAN
CLASS="TYPE"
>transactionid</SPAN
>. (This method is used by the timer module)</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1469"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>sipevent_t *osip_new_event</CODE
>(type_t type
int transactionid);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-NEW-INCOMING-EVENT"
>osip_new_incoming_event</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1479"
></A
><H2
>Name</H2
>osip_new_incoming_event&nbsp;--&nbsp;create a new SIP event for an incoming SIP message.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1482"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>sipevent_t *osip_new_incoming_event</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-NEW-OUTGOING-EVENT"
>osip_new_outgoing_event</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1491"
></A
><H2
>Name</H2
>osip_new_outgoing_event&nbsp;--&nbsp;create a new SIP event for an outgoing SIP message.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1494"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>sipevent_t *osip_new_outgoing_event</CODE
>(sip_t *sip);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-FIND-ASINCOMINGMESSAGE"
>osip_find_asincomingmessage</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1503"
></A
><H2
>Name</H2
>osip_find_asincomingmessage&nbsp;--&nbsp;find (or create) the transaction related to the SIP incoming event.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1506"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>transaction_t *osip_find_asincomingmessage</CODE
>(osip_t *osip
sipevent_t *sipevent);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-FIND-ASOUTGOINGMESSAGE"
>osip_find_asoutgoingmessage</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1516"
></A
><H2
>Name</H2
>osip_find_asoutgoingmessage&nbsp;--&nbsp;find the transaction related to the SIP outgoing event.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1519"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>transaction_t *osip_find_asoutgoingmessage</CODE
>(osip_t *osip
sipevent_t *sipevent);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-FIND-BYID"
>osip_find_byid</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1529"
></A
><H2
>Name</H2
>osip_find_byid&nbsp;--&nbsp;find the transaction with <TT
CLASS="PARAMETER"
><I
>transactionid</I
></TT
> attribute.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1533"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>transaction_t *osip_find_byid</CODE
>(osip_t *osip
int transactionid);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.OSIP-REMOVE-BYID"
>osip_remove_byid</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1543"
></A
><H2
>Name</H2
>osip_remove_byid&nbsp;--&nbsp;remove the transaction with <TT
CLASS="PARAMETER"
><I
>transactionid</I
></TT
> attribute.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1547"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int osip_remove_byid</CODE
>(osip_t *osip
int transactionid);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TRANSACTION-INIT"
>transaction_init</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1557"
></A
><H2
>Name</H2
>transaction_init&nbsp;--&nbsp;Allocate and initialize the <TT
CLASS="PARAMETER"
><I
>transaction</I
></TT
> element.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1561"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int transaction_init</CODE
>(transaction_t **transaction);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TRANSACTION-FREE"
>transaction_free</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1570"
></A
><H2
>Name</H2
>transaction_free&nbsp;--&nbsp;free resources contained in <TT
CLASS="PARAMETER"
><I
>transaction</I
></TT
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1574"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>void transaction_free</CODE
>(transaction_t *transaction);</CODE
></P
><P
></P
></DIV
></DIV
><H1
><A
NAME="FUNCTION.TRANSACTION-EXECUTE"
>transaction_execute</A
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN1583"
></A
><H2
>Name</H2
>transaction_execute&nbsp;--&nbsp;consume sipevent in the context of <TT
CLASS="PARAMETER"
><I
>transaction</I
></TT
>.</DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN1587"
></A
><H2
>Description</H2
><DIV
CLASS="FUNCSYNOPSIS"
><P
></P
><P
><CODE
><CODE
CLASS="FUNCDEF"
>int transaction_execute</CODE
>(transaction_t *transaction);</CODE
></P
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1595"
>The callbacks.</A
></H2
><P
>oSIP uses a set of callbacks to announce the evolution of SIP transactions. For example, when receiving an INVITE request, the method registered by "osip_setcb_rcvinvite(...)" will be called by the stack and used by the developer to create a provisional response and start actions to build a final one.</P
><P
>The following methods allow you to register, on initialization of the osip stack, the methods that will be used to handle transactions. Some of those methods are mandatory (announcements of requests, and final responses) and some are optional (announcements of provisional responses and retransmissions).</P
><PRE
CLASS="PROGRAMLISTING"
>void osip_setcb_rcvinvite  (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvack     (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvbye     (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvcancel  (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvinfo    (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvoptions (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvregister(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvprack   (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcvunkrequest(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));

void osip_setcb_sndinvite  (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndack     (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndbye     (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndcancel  (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndinfo    (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndoptions (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndregister(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndprack   (osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_sndunkrequest(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));

void osip_setcb_rcv1xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcv2xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcv3xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcv4xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcv5xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_rcv6xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));

void osip_setcb_snd1xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_snd2xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_snd3xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_snd4xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_snd5xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));
void osip_setcb_snd6xx(osip_t *cf,void (*cb)(sipevent_t*,transaction_t*));

void osip_setcb_rcvresp_retransmission(osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_sndreq_retransmission (osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_sndresp_retransmission(osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_rcvreq_retransmission (osip_t *cf,void (*cb)(transaction_t*));

void osip_setcb_killtransaction   (osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_endoftransaction  (osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_connection_refused(osip_t *cf,void (*cb)(transaction_t*));
void osip_setcb_network_error     (osip_t *cf,void (*cb)(transaction_t*));</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1600"
>Useful MACROs.</A
></H2
><P
>You can also use the following list of MACROs. It is recommended to use them if you want your application to keep full compatibility over oSIP releases.</P
><PRE
CLASS="PROGRAMLISTING"
>/* FOR INCOMING TRANSACTION */
#define EVT_IS_RCV_INVITE(event)       (event-&#62;type==RCV_REQINVITE)
#define EVT_IS_RCV_ACK(event)          (event-&#62;type==RCV_REQACK)
#define EVT_IS_RCV_REQUEST(event)      (event-&#62;type==RCV_REQUEST)
#define EVT_IS_RCV_STATUS_1XX(event)   (event-&#62;type==RCV_STATUS_1XX)
#define EVT_IS_RCV_STATUS_23456XX(event)   (event-&#62;type==RCV_STATUS_23456XX)

/* FOR OUTGOING TRANSACTION */
#define EVT_IS_SND_INVITE(event)       (event-&#62;type==SND_REQINVITE)
#define EVT_IS_SND_ACK(event)          (event-&#62;type==SND_REQACK)
#define EVT_IS_SND_REQUEST(event)      (event-&#62;type==SND_REQUEST)
#define EVT_IS_SND_STATUS_1XX(event)   (event-&#62;type==SND_STATUS_1XX)
#define EVT_IS_SND_STATUS_23456XX(event)   (event-&#62;type==SND_STATUS_23456XX)

#define EVT_IS_INCOMINGMSG(event)      (event-&#62;type&#62;=RCV_REQINVITE \
                	               &#38;&#38;event-&#62;type&#60;=RCV_STATUS_23456XX)
#define EVT_IS_INCOMINGREQ(event)      (EVT_IS_RCV_INVITE(event) \
                                       ||EVT_IS_RCV_ACK(event) \
                                       ||EVT_IS_RCV_REQUEST(event))
#define EVT_IS_INCOMINGRESP(event)     (EVT_IS_RCV_STATUS_1XX(event) \
                                       ||EVT_IS_RCV_STATUS_23456XX(event))
#define EVT_IS_OUTGOINGMSG(event)      (event-&#62;type&#62;=SND_REQINVITE \
                	               &#38;&#38;event-&#62;type&#60;=SND_STATUS_23456XX)
#define EVT_IS_OUTGOINGREQ(event)      (EVT_IS_SND_INVITE(event) \
                                       ||EVT_IS_SND_ACK(event) \
                                       ||EVT_IS_SND_REQUEST(event))
#define EVT_IS_OUTGOINGRESP(event)     (EVT_IS_SND_STATUS_1XX(event) \
                                       ||EVT_IS_SND_STATUS_23456XX(event))
#define EVT_IS_MSG(event)              (event-&#62;type&#62;=RCV_REQINVITE \
                	               &#38;&#38;event-&#62;type&#60;=SND_STATUS_23456XX)
#define EVT_IS_KILL_TRANSACTION(event) (event-&#62;type==KILL_TRANSACTION)
#define EVT_IS_UNKNOWN_EVT(event)      (event-&#62;type==UNKNOWN_EVT)
#define EVT_IS_TIMEOUT(event)          (event-&#62;type==TIMEOUT)</PRE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1604"
>The finite state machines HOW-TO</A
></H1
><P
>oSIP contains 4 finite state machines. SIP defines 2 kinds of transactions. INVITE and other than INVITE transactions differs slightly. INVITE transactions must be followed by an ACK which is part of the state machine for INVITE. Also, different rules apply for retransmission mechanism.</P
><P
>A finite state machine is an ideal way to implement the transaction layer. Threads are waiting for events. Events come from the user layer, transport layer or the timer management facility. The stack always provides information about the state of the transaction to the application layer. This is done through the set of dynamic callbacks.
<DIV
CLASS="EXAMPLE"
><P
><B
>Example 5-4. SIP events are distributed to fifo.</B
></P
><PRE
CLASS="PROGRAMLISTING"
>                                                    Transaction
          User Layer                                  contexts
        +------------+                             +-----------+
        |            |    events          +--------|           |
        |            |-----+-------------&#62;| FIFO 1 |     1     |
        +------------+     |              +--------|           |
                           |                       +-----------+
                           |
                           |                       +-----------+
                           |              +--------|           |
                           +-------------&#62;| FIFO N |     N     |
                                          +--------|           |
                                                   +-----------+</PRE
></DIV
></P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1611"
>Initialise the osip stack</A
></H2
><P
>The oSIP stack needs to be initialised at run time. This is done by first calling the following method before using the oSIP stack. (This method MUST only be called once). Calling this method also initialise the parser.</P
><P
>int <FONT
COLOR="RED"
>osip_global_init()</FONT
>;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1616"
>Allocate and initialize an osip_t element</A
></H2
><P
>The osip_t structure is a container for a list of transactions. This element represents an instance of a SIP agent. osip_t can be used for UAS/UAC, registrar and redirect server.</P
><P
>The following code is used to build a complete osip_t element. First, you have to register a set of mandatory and optional callbacks. You can also configure the stack to use a proxy for all outgoing requests.</P
><PRE
CLASS="PROGRAMLISTING"
>  osip_t  *osip;

  if (-1==osip_global_init())
    return -1; /* mutex is not initialized properly */

  osip_init(&#38;osip);
  osip_init_proxy(osip,url_of_proxy);

  osip_setcb_rcvresp_retransmission(cf,&#38;cb_rcvresp_retransmission);
  osip_setcb_sndreq_retransmission(cf,&#38;cb_sndreq_retransmission);
  osip_setcb_sndresp_retransmission(cf,&#38;cb_sndresp_retransmission);
  osip_setcb_rcvreq_retransmission(cf,&#38;cb_rcvreq_retransmission);
  
  osip_setcb_killtransaction(cf,&#38;cb_killtransaction);
  osip_setcb_endoftransaction(cf,&#38;cb_endoftransaction);
  
  osip_setcb_connection_refused(cf,&#38;cb_connection_refused);
  osip_setcb_network_error(cf,&#38;cb_network_error);
  
  osip_setcb_rcv1xx(cf,&#38;cb_rcv1xx);
  osip_setcb_rcv2xx(cf,&#38;cb_rcv2xx);
  osip_setcb_rcv3xx(cf,&#38;cb_rcv3xx);
  osip_setcb_rcv4xx(cf,&#38;cb_rcv4xx);
  osip_setcb_rcv5xx(cf,&#38;cb_rcv5xx);
  osip_setcb_rcv6xx(cf,&#38;cb_rcv6xx);
  
  osip_setcb_sndinvite  (cf,&#38;cb_sndinvite);
  osip_setcb_sndack     (cf,&#38;cb_sndack);
  osip_setcb_sndbye     (cf,&#38;cb_sndbye);
  osip_setcb_sndcancel  (cf,&#38;cb_sndcancel);
  osip_setcb_sndinfo    (cf,&#38;cb_sndinfo);
  osip_setcb_sndoptions (cf,&#38;cb_sndoptions);
  osip_setcb_sndregister(cf,&#38;cb_sndregister);
  osip_setcb_sndprack   (cf,&#38;cb_sndprack);
  osip_setcb_sndunkrequest(cf,&#38;cb_sndunkrequest);

  osip_setcb_snd1xx(cf,&#38;cb_snd1xx);
  osip_setcb_snd2xx(cf,&#38;cb_snd2xx);
  osip_setcb_snd3xx(cf,&#38;cb_snd3xx);
  osip_setcb_snd4xx(cf,&#38;cb_snd4xx);
  osip_setcb_snd5xx(cf,&#38;cb_snd5xx);
  osip_setcb_snd6xx(cf,&#38;cb_snd6xx);

  osip_setcb_rcvinvite  (cf,&#38;cb_rcvinvite);
  osip_setcb_rcvack     (cf,&#38;cb_rcvack);
  osip_setcb_rcvbye     (cf,&#38;cb_rcvbye);
  osip_setcb_rcvcancel  (cf,&#38;cb_rcvcancel);
  osip_setcb_rcvinfo    (cf,&#38;cb_rcvinfo);
  osip_setcb_rcvoptions (cf,&#38;cb_rcvoptions);
  osip_setcb_rcvregister(cf,&#38;cb_rcvregister);
  osip_setcb_rcvprack   (cf,&#38;cb_rcvprack);
  osip_setcb_rcvunkrequest(cf,&#38;cb_rcvunkrequest);</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1621"
>Send events to control transaction</A
></H2
><P
>Here is a sample to initiate a transaction. The initial event sent to the FIFO contains the first INVITE request. The creation of the message is not shown here.</P
><PRE
CLASS="PROGRAMLISTING"
>int
create_session(osip_t *osip)
{
  sip_t         *invite;
  transaction_t *transaction;

  /* You must create your own SIP message. */
  msg_init (&#38;invite);
  your_own_method_to_setup_messages(invite);

  /* When it is the first invite, allocate    */
  /* and start a new transaction (prepare the
  /* context and start a thread.)             */
  trn_init(&#38;transaction,
	   osip,
	   invite-&#62;to,
	   invite-&#62;from,
	   invite-&#62;callid,
	   invite-&#62;cseq);

  /* The thread is now waiting on its FIFO  */
  /* The following method allocate an event */
  /* and send it to the transaction.        */
  osip_sendmsg(transaction,invite);
}

int
osip_sendmsg(transaction_t *transaction,sip_t *msg)
{
    sipevent_t *sipevent;

    sipevent = osip_new_outgoing_sipmessage(msg);
    sipevent-&#62;transactionid =  transaction-&#62;transactionid;

/* depending on your application model, you can choose */
/* either to consume the event are add it in the fifo  */
/* and delay the operations */

#ifdef OSIP_MT
    fifo_add(transaction-&#62;transactionff,sipevent);
#else
    transaction_execute(transaction,sipevent);
#endif

    return 0;
}&#13;</PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN1625"
>Notes for proxy implementation</A
></H2
><P
>The transaction layer provided for oSIP is usable by user agents, registrar, redirect server and some type of conference server. A state machine for statefull proxy will be added in the future. The existing state machines are not easily usable for proxy implementation!</P
><P
>For stateless proxy, a state machine is very simple (No state is needed!). Nevertheless, A state machine will be implemented. its only role will be to cache results for a short time.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN1629"
>Build your own architecture</A
></H1
><P
>Since release 0.7.0, the stack can be used without semaphore and thread support. The design is completely up to you. You have to choose a design that fit the type of application. Here are the different aspect that you need to take care of:</P
><P
></P
><TABLE
BORDER="0"
><TR
><TD
>choose which transport protocol you want (UDP is recommended)</TD
></TR
><TR
><TD
>use one socket for all transactions or one per each.</TD
></TR
><TR
><TD
>choose a multi thread design or not.</TD
></TR
><TR
><TD
>choose how to start timers.</TD
></TR
></TABLE
><P
></P
><P
>By now, UDP is recommended for SIP for servers as well as other user agents. When implementing a server, you may face many parallel transactions. If you use one connection per each transaction, the application may run quickly out of resources. (Also, you can't always guess if other applications on the same computer require many sockets too). For servers, you may also take care when using a multi threaded architecture with one thread per transactions. For a highly used server, you may quickly run out of thread resources. (Specifically, the standard kernel from debian support a low number of threads).</P
><P
>If your application wants to access a database and make IP address resolution, this could leave your application in a blocked state for a while. In this case, a multi threaded application could be very useful and avoid some issues. It worth to say that performance of your application will heavily rely on how you will deal with those issue.</P
></DIV
></DIV
><A
NAME="AEN1639"
></A
><HR><H1
><A
NAME="AEN1639"
>Bibliography</A
></H1
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN1640"
></A
><P
>SIP, <I
>Session Initiation Protocole - rfc2543.txt</I
>, ietf.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left=0.5in"
></DIV
></DIV
><DIV
CLASS="BIBLIOENTRY"
><A
NAME="AEN1645"
></A
><P
>SDP, <I
>Session Description Protocole - rfc2327.txt</I
>, ietf.</P
><DIV
CLASS="BIBLIOENTRYBLOCK"
STYLE="margin-left=0.5in"
></DIV
></DIV
></DIV
></BODY
></HTML
>